#!/usr/bin/env node

/**
 * Performance Benchmark Script
 * Measures build time, bundle size, and runtime performance
 *
 * Usage: node scripts/benchmark.js
 */

const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

const COLORS = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  red: "\x1b[31m",
};

function log(message, color = COLORS.reset) {
  console.log(`${color}${message}${COLORS.reset}`);
}

function measureBuildTime() {
  log("\nüìä Measuring Build Time...", COLORS.blue);

  const start = Date.now();
  try {
    execSync("pnpm build", { stdio: "pipe" });
    const duration = ((Date.now() - start) / 1000).toFixed(2);
    log(`‚úÖ Build completed in ${duration}s`, COLORS.green);
    return duration;
  } catch (error) {
    log("‚ùå Build failed", COLORS.red);
    return null;
  }
}

function measureBundleSize() {
  log("\nüì¶ Measuring Bundle Size...", COLORS.blue);

  const buildDir = path.join(process.cwd(), ".next");

  if (!fs.existsSync(buildDir)) {
    log("‚ùå Build directory not found", COLORS.red);
    return null;
  }

  // Measure First Load JS
  const staticDir = path.join(buildDir, "static");
  let totalSize = 0;

  function getDirectorySize(dir) {
    const files = fs.readdirSync(dir, { withFileTypes: true });

    for (const file of files) {
      const filePath = path.join(dir, file.name);

      if (file.isDirectory()) {
        getDirectorySize(filePath);
      } else if (file.name.endsWith(".js") || file.name.endsWith(".css")) {
        const stats = fs.statSync(filePath);
        totalSize += stats.size;
      }
    }
  }

  if (fs.existsSync(staticDir)) {
    getDirectorySize(staticDir);
  }

  const sizeInKB = (totalSize / 1024).toFixed(2);
  log(`‚úÖ Total JS/CSS: ${sizeInKB} KB`, COLORS.green);

  return sizeInKB;
}

function analyzeClientComponents() {
  log("\nüîç Analyzing Client Components...", COLORS.blue);

  try {
    const output = execSync(
      'grep -r "use client" src/modules --include="*.tsx" | wc -l',
      { encoding: "utf-8" }
    );

    const count = parseInt(output.trim());
    log(`üìä Client Components: ${count}`, COLORS.yellow);

    return count;
  } catch (error) {
    log("‚ùå Analysis failed", COLORS.red);
    return null;
  }
}

function generateReport(results) {
  log("\nüìÑ Generating Report...", COLORS.blue);

  const report = `
# Performance Benchmark Report

**Date:** ${new Date().toISOString()}
**Next.js Version:** 16.0.7
**React Version:** 19.2.1

## Build Performance

- **Build Time:** ${results.buildTime || "N/A"}s
- **Bundle Size:** ${results.bundleSize || "N/A"} KB
- **Client Components:** ${results.clientComponents || "N/A"}

## Optimization Status

### ‚úÖ Completed
- [x] Turbopack enabled
- [x] Filesystem caching enabled
- [x] React Strict Mode enabled
- [x] Tree-shaking optimized
- [x] Image optimization (Next.js 16 defaults)
- [x] Proxy.ts migration

### ‚è≥ In Progress
- [ ] Cache Components implementation
- [ ] Client component optimization
- [ ] React Compiler integration

## Recommendations

${
  results.bundleSize > 350
    ? "‚ö†Ô∏è Bundle size is large. Consider:\n- More code splitting\n- Remove unused dependencies\n- Optimize images\n"
    : "‚úÖ Bundle size is optimized\n"
}

${
  results.clientComponents > 40
    ? "‚ö†Ô∏è Many client components detected. Consider:\n- Move logic to server components\n- Split large client components\n- Use server actions for forms\n"
    : "‚úÖ Client component usage is reasonable\n"
}

## Next Steps

1. Enable Cache Components for static pages
2. Implement React Compiler for auto-memoization
3. Monitor Core Web Vitals in production
4. Set up performance budgets

---

*Generated by Next.js 16 Benchmark Script*
`;

  const reportPath = path.join(process.cwd(), "PERFORMANCE_REPORT.md");
  fs.writeFileSync(reportPath, report);

  log(`‚úÖ Report saved to ${reportPath}`, COLORS.green);
}

function displayComparison() {
  log("\nüìä Expected vs Actual Performance", COLORS.bright);

  console.table([
    {
      Metric: "Build Time",
      Before: "~60s",
      Expected: "~30s",
      Target: "2x faster",
    },
    {
      Metric: "Fast Refresh",
      Before: "~2s",
      Expected: "~200ms",
      Target: "10x faster",
    },
    {
      Metric: "Bundle Size",
      Before: "~400KB",
      Expected: "~300KB",
      Target: "25% smaller",
    },
    {
      Metric: "Client Components",
      Before: "57",
      Expected: "35",
      Target: "38% reduction",
    },
  ]);
}

async function main() {
  log("\nüöÄ Starting Performance Benchmark...", COLORS.bright);
  log("=".repeat(50), COLORS.bright);

  const results = {
    buildTime: measureBuildTime(),
    bundleSize: measureBundleSize(),
    clientComponents: analyzeClientComponents(),
  };

  displayComparison();
  generateReport(results);

  log("\n" + "=".repeat(50), COLORS.bright);
  log("‚úÖ Benchmark Complete!", COLORS.green);
  log("\nNext Steps:");
  log("1. Review PERFORMANCE_REPORT.md", COLORS.yellow);
  log("2. Run: pnpm analyze (for detailed bundle analysis)", COLORS.yellow);
  log("3. Test in production: pnpm build && pnpm start", COLORS.yellow);
}

main().catch((error) => {
  log(`\n‚ùå Error: ${error.message}`, COLORS.red);
  process.exit(1);
});
